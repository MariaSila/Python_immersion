# Представление для пользователя, __str__
# Представление для создания экземпляра,__repr__
# Приоритет методов

# Для получения читаемого описания необходимо переопределить как
# минимум один из дандер методов: __str__ или __repr__.

# Представление для пользователя, __str__
# Функция print ищет __str__ для вывода информации в консоль

# Представление для создания экземпляра, __repr__
# Строка должна создать новый экземпляр, если скопировать её в код


# ----------------------------------------------------------------------------
# STEP 1. Представление для пользователя, __str__
# Дандер метод __str__ используется для получения удобного пользователю описания экземпляра.
# Метод __str__ обязан вернуть строку str. Обычно это строка содержит информацию
# о свойствах класса для понимания что за экземпляр перед нами. Упор делается на
# удобство чтения. Но и о краткости забывать не стоит.

# class User:
#     def __init__(self, name: str):
#         """Added the name parameter."""
#         self.name = name
#
#     def simple_method(self):
#         """Example of a simple method."""
#         self.name.capitalize()
#
#     def __str__(self):
#         return f'Экземпляр класса User с именем "{self.name}"'
#
#
# user = User('Спенглер')
# print(user)

# => Экземпляр класса User с именем "Спенглер"


# ----------------------------------------------------------------------
# STEP 2.1. Представление для создания экземпляра, __repr__
# Дандер метод __repr__ аналогичен __str__, но возвращает максимально близкое к
# созданию экземпляра класса представление.

# class User:
#     def __init__(self, name: str):
#         """Added the name parameter."""
#         self.name = name
#
#     def simple_method(self):
#         """Example of a simple method."""
#         self.name.capitalize()
#
#     def __repr__(self):
#         return f'User({self.name})'
#
#
# user = User('Спенглер')
# print(user)

# => User(Спенглер)


# .................................................................................
# STEP 2.2. Если скопировать вывод метода repr и присвоить его переменной, должен
# получится ещё один экземпляр класса. Рассмотрим более сложный класс и его метод __repr__.
# Мы снова получили строку, которую можно скопировать и создать экземпляр без
# внесения правок. При этом свойство life опущено в выводе, т.к. не влияет на создание экземпляра.

# class User:
#     def __init__(self, name: str, equipment: list = None):
#         self.name = name
#         self.equipment = equipment if equipment is not None else []
#         self.life = 3
#
#     def __repr__(self):
#         return f'User({self.name}, {self.equipment})'
#
#
# user = User('Венкман', ['протонный ускоритель', 'ловушка'])
# print(user)

# => User(Венкман, ['протонный ускоритель', 'ловушка'])


# ----------------------------------------------------------------------
# STEP 3. Приоритет методов
#   Варианты срабатывания __str__ и __repr__
#       ● print(user)
#           __str__
#       ● print(f'{user}')
#           __str__
#       ● print(repr(user))
#           __repr__
#       ● print(f'{user = }')
#           __repr__
#       ● print(collections)
#           __repr__

# Добавим классу из примера выше метод __str__ и посмотрим какой из них сработает
# При вызове функции print сработал метод __str__.

# class User:
#     def __init__(self, name: str, equipment: list = None):
#         self.name = name
#         self.equipment = equipment if equipment is not None else []
#         self.life = 3
#
#     def __str__(self):
#         eq = 'оборудованием: ' + ', '.join(self.equipment) if self.equipment else 'пустыми руками'
#         return f'Перед нами {self.name} с {eq}. Количество жизней - {self.life}'
#
#     def __repr__(self):
#         return f'User({self.name}, {self.equipment})'
#
#
# user = User('Венкман', ['протонный ускоритель', 'ловушка'])
# print(user)

# => Перед нами Венкман с оборудованием: протонный ускоритель, ловушка. Количество жизней - 3


# ....................................................................
# Как же получить вывод от __repr__ при наличии двух методов?
# Есть несколько способов вывода на печать.
# В первых двух вариантах срабатывает дандер __str__. Далее мы явно передаём в
# print результат встроенной функции repr, которая обращается к одноимённому
# методу. Так же при использовании f-строк символ равенства выводит имя
# переменной слева от знака равно и repr справа от него.

# class User:
#     def __init__(self, name: str, equipment: list = None):
#         self.name = name
#         self.equipment = equipment if equipment is not None else []
#         self.life = 3
#
#     def __str__(self):
#         eq = 'оборудованием: ' + ', '.join(self.equipment) if self.equipment else 'пустыми руками'
#         return f'Перед нами {self.name} с {eq}. Количество жизней - {self.life}'
#
#     def __repr__(self):
#         return f'User({self.name}, {self.equipment})'
#
#
# user = User('Венкман', ['протонный ускоритель', 'ловушка'])
# print(user)
# print(f'{user}')
# print(repr(user))
# print(f'{user = }')

# => Перед нами Венкман с оборудованием: протонный ускоритель, ловушка. Количество жизней - 3
# => Перед нами Венкман с оборудованием: протонный ускоритель, ловушка. Количество жизней - 3
# => User(Венкман, ['протонный ускоритель', 'ловушка'])
# => user = User(Венкман, ['протонный ускоритель', 'ловушка'])


# ...........................................................................
# Печать коллекций
# Однако метод __repr__ оказывается более приоритетным, если на печать выводится
# не один элемент, а коллекция элементов
# В приведённом примере список из трёх экземпляров при печати возвращает repr
# представление во всех четырёх рассмотренных способах. И только при распаковке
# списка через звёздочку функция print получает экземпляры напрямую и вызывает их дандер __str__.

# class User:
#     def __init__(self, name: str, equipment: list = None):
#         self.name = name
#         self.equipment = equipment if equipment is not None else []
#         self.life = 3
#
#     def __str__(self):
#         eq = 'оборудованием: ' + ', '.join(self.equipment) if self.equipment else 'пустыми руками'
#         return f'Перед нами {self.name} с {eq}. Количество жизней - {self.life}'
#
#     def __repr__(self):
#         return f'User({self.name}, {self.equipment})'
#
#
# u_1 = User('Спенглер')
# u_2 = User('Венкман', ['протонный ускоритель', 'ловушка'])
# u_3 = User(equipment=['ловушка', 'прибор ночного видения'], name='Стэнц')
#
# ghostbusters = [u_1, u_2, u_3]
#
# print(ghostbusters)
# print(f'{ghostbusters}')
# print(repr(ghostbusters))
# print(f'{ghostbusters = }')
# print(*ghostbusters, sep='\n')

# => [User(Спенглер, []), User(Венкман, ['протонный ускоритель', 'ловушка']),
#       User(Стэнц, ['ловушка', 'прибор ночного видения'])]
# => [User(Спенглер, []), User(Венкман, ['протонный ускоритель', 'ловушка']),
#       User(Стэнц, ['ловушка', 'прибор ночного видения'])]
# => [User(Спенглер, []), User(Венкман, ['протонный ускоритель', 'ловушка']),
#       User(Стэнц, ['ловушка', 'прибор ночного видения'])]
# => ghostbusters = [User(Спенглер, []), User(Венкман, ['протонный ускоритель', 'ловушка']),
#       User(Стэнц, ['ловушка', 'прибор ночного видения'])]
# => Перед нами Спенглер с пустыми руками. Количество жизней - 3
# => Перед нами Венкман с оборудованием: протонный ускоритель, ловушка. Количество жизней - 3
# => Перед нами Стэнц с оборудованием: ловушка, прибор ночного видения. Количество жизней - 3
