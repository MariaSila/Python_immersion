# Задача 4. Кэширование для ускорения вычислений
# Создайте декоратор, который кэширует (сохраняет для дальнейшего использования)
# результаты вызова функции и, при повторном вызове с теми же аргументами,
# возвращает сохранённый результат.
# Примените его к рекурсивной функции вычисления чисел Фибоначчи.
# В итоге декоратор должен проверять аргументы, с которыми вызывается функция, и,
# если такие аргументы уже использовались, должен вернуть сохранённый результат
# вместо запуска расчёта.
# Подсказка № 1
# Используйте словарь для хранения кэшированных результатов. Создайте словарь
# внутри декоратора для хранения результатов вызова функции с определёнными
# аргументами. Это позволит быстро проверять, были ли уже вычислены результаты для
# этих аргументов.
# Подсказка № 2
# Внутри функции-обертки проверьте, содержится ли результат для текущих аргументов
# в словаре кэша. Если результат есть, верните его, иначе вызовите декорируемую
# функцию и сохраните результат в кэш.
# Подсказка № 3
# Используйте csv.DictWriter для записи данных в новый CSV файл. Запишите итоговые
# данные в новый файл, указывая заголовки столбцов и записывая итоговую выручку
# для каждого продукта.
# Подсказка № 4
# Примените декоратор к рекурсивной функции вычисления чисел Фибоначчи.
# Используйте декоратор для функции, вычисляющей числа Фибоначчи. Убедитесь, что
# кэширование работает корректно, чтобы избежать повторных вычислений.
from typing import Callable
from functools import wraps


def cash(func: Callable):
    dict_cash = {}

    @wraps(func)
    def wrapper(*args):
        if args not in dict_cash:
            dict_cash[args] = func(*args)
        return dict_cash[args]
    return wrapper


@cash
def fibonacci(n):
    """Рекурсивная функция вычисляет число Фибоначчи"""
    print(f'Вычисляю число {n} Фибоначчи')
    if n in (1, 2):
        return 1
    return fibonacci(n - 1) + fibonacci(n - 2)


if __name__ == '__main__':
    print(f'{fibonacci.__name__=} ')
    print(help(fibonacci))
    print(fibonacci(5))
    print(fibonacci(3))
    print(fibonacci(8))
    print(fibonacci(10))


# # perfect solution
# def cache_decorator(func):
#     """
#     Декоратор для кэширования результатов функции.
#     :param func: Декорируемая функция
#     :return: Функция-обертка с кэшированием
#     """
#     cache = {} # Словарь для хранения кэшированных результатов
#     def wrapper(number):
#         """
#         Функция-обертка, которая сначала проверяет кэш перед вызовом
#         функции.
#         :param number: Аргумент для декорируемой функции
#         :return: Результат выполнения функции
#         """
#         if number in cache:
#             return cache[number]
#         result = func(number)
#         cache[number] = result # Сохраняем результат в кэше
#         return result
#     return wrapper
#
#
# @cache_decorator
# def fibonacci(number):
#     """
#     Функция для вычисления чисел Фибоначчи с использованием
#     рекурсии.
#     :param number: Позиция числа Фибоначчи
#     :return: Число Фибоначчи
#     """
#     if number <= 1:
#         return number
#     return fibonacci(number - 1) + fibonacci(number - 2)
#
#
# print(fibonacci(10))
# print(fibonacci(10))
# print(fibonacci(5))
